using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

using Nustache.Core;

namespace Refit.Generator
{
    // * Search for all Interfaces, find the method definitions
    //   and make sure there's at least one Refit attribute on one
    // * Generate the data we need for the template based on interface method
    //   defn's
    // * Get this into an EXE in tools, write a targets file to beforeBuild execute it
    // * Get a props file that adds a dummy file to the project
    // * Write an implementation of RestService that just takes the interface name to
    //   guess the class name based on our template
    //
    // What if the Interface is in another module? (since we copy usings, should be fine)
    [Generator]
    public class InterfaceStubGenerator : ISourceGenerator
    {
        static readonly HashSet<string> HttpMethodAttributeNames = new(
            new[] { "Get", "Head", "Post", "Put", "Delete", "Patch", "Options" }
                .SelectMany(x => new[] { "{0}", "{0}Attribute" }.Select(f => string.Format(f, x))));


        public void Execute(GeneratorExecutionContext context)
        {
            GenerateInterfaceStubs(context);            
        }

        public static string ExtractTemplateSource()
        {
            var ourPath = Path.Combine(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), "GeneratedInterfaceStubTemplate.mustache");

            // Try to return a flat file from the same directory, if it doesn't
            // exist, use the built-in resource version
            if (File.Exists(ourPath))
            {
                return File.ReadAllText(ourPath, Encoding.UTF8);
            }

            using var src = typeof(InterfaceStubGenerator).Assembly.GetManifestResourceStream("Refit.Generator.GeneratedInterfaceStubTemplate.mustache");
            var ms = new MemoryStream();
            src.CopyTo(ms);
            return Encoding.UTF8.GetString(ms.ToArray());
        }
               

        public List<InterfaceDeclarationSyntax> FindInterfacesToGenerate(SyntaxTree tree)
        {
            var nodes = tree.GetRoot().DescendantNodes().ToList();

            // Make sure this file imports Refit. If not, we're not going to
            // find any Refit interfaces
            // NB: This falls down in the tests unless we add an explicit "using Refit;",
            // but we can rely on this being there in any other file
            if (nodes.OfType<UsingDirectiveSyntax>().All(u => u.Name.ToFullString() != "Refit"))
                return new List<InterfaceDeclarationSyntax>();

            var list = nodes.OfType<InterfaceDeclarationSyntax>();

            return list
                .Where(i => i.DescendantsAndSelf(a => a.BaseList?.Types.Select(b => b.GetSimpleName())
                    .Where(b => b != null).Select(b => b.GetInterfaceDeclaration(list)))
                    .Any(b => b.Members.OfType<MethodDeclarationSyntax>().Any(HasRefitHttpMethodAttribute)))
                .ToList();
        }



        public ClassTemplateInfo GenerateClassInfoForInterface(InterfaceDeclarationSyntax interfaceTree)
        {
            var ret = new ClassTemplateInfo();
            var parent = interfaceTree.Parent;
            while (parent != null && !(parent is NamespaceDeclarationSyntax)) parent = parent.Parent;

            ret.InterfaceName = GetInterfaceName(interfaceTree.Identifier);
            ret.GeneratedClassSuffix = ret.InterfaceName.Replace(".", "");
            ret.Modifiers = interfaceTree.Modifiers.Select(t => t.ValueText).FirstOrDefault(m => m == "public" || m == "internal");
            ret.BaseClasses = interfaceTree.BaseList?.Types.Select(b => b.GetSimpleName()).Where(b => b != null)
                .Select(t => new BaseClassInfo
                {
                    Name = t.Identifier.ValueText,
                    TypeParametersInfo = (t is GenericNameSyntax g ? g.TypeArgumentList.Arguments.Select(a => a.GetTypeInfo()).ToList() : null)
                }).ToList();

            var ns = parent as NamespaceDeclarationSyntax;
            ret.Namespace = ns?.Name?.ToString() ?? $"AutoGenerated{ret.GeneratedClassSuffix}";

            if (interfaceTree.TypeParameterList != null)
            {
                var typeParameters = interfaceTree.TypeParameterList.Parameters;
                if (typeParameters.Any())
                {
                    ret.TypeParametersInfo = typeParameters.Select(p => p.Identifier.ValueText).ToList();
                }

                ret.ConstraintClauses = interfaceTree.ConstraintClauses.ToFullString().Trim();
            }

            var rootNode = interfaceTree.Parent;
            while (rootNode.Parent != null) rootNode = rootNode.Parent;

            var usingsInsideNamespace = ns?.DescendantNodes()
                            .OfType<UsingDirectiveSyntax>()
                            .Select(x => $"{x.Alias} {x.StaticKeyword} {x.Name}".TrimStart())
                            ?? Enumerable.Empty<string>();

            var usingsOutsideNamespace = rootNode.DescendantNodes(x => !x.IsKind(SyntaxKind.NamespaceDeclaration))
                            .OfType<UsingDirectiveSyntax>()
                            .Select(x =>
                            {
                                // Globally qualify namespace name to avoid conflicts when put inside namespace.
                                var name = x.Name.ToString();
                                var globallyQualifiedName = name.Contains("::")
                                    ? name
                                    : "global::" + name;

                                return $"{x.Alias} {x.StaticKeyword} {globallyQualifiedName}".TrimStart();
                            });

            var usings = usingsInsideNamespace.Concat(usingsOutsideNamespace)
                            .Distinct()
                            .Where(x => x != "System" && x != "System.Net.Http" && x != "System.Collections.Generic" && x != "System.Linq")
                            .Select(x => new UsingDeclaration { Item = x });

            ret.UsingList = usings.ToList();

            ret.MethodList = interfaceTree.Members
                                          .OfType<MethodDeclarationSyntax>()
                                          .Where(mti => !mti.Modifiers.Any(SyntaxKind.StaticKeyword)) // Generated methods can't be static on the interface
                                          .Select(x =>
                                          {
                                              var mti = new MethodTemplateInfo
                                              {
                                                  Name = x.Identifier.Text,
                                                  InterfaceName = ret.InterfaceName,
                                                  TypeParametersInfo = ret.TypeParametersInfo?.ToList(),
                                                  ReturnTypeInfo = x.ReturnType.GetTypeInfo(),
                                                  ArgumentListInfo = x.ParameterList.Parameters
                                                    .Select(a => new ArgumentInfo { Name = a.Identifier.Text, TypeInfo = a.Type.GetTypeInfo() })
                                                    .ToList(),
                                                  IsRefitMethod = HasRefitHttpMethodAttribute(x)
                                              };
                                              if (x.TypeParameterList != null)
                                              {
                                                  var typeParameters = x.TypeParameterList.Parameters;
                                                  if (typeParameters.Any())
                                                  {
                                                      mti.MethodTypeParameterListInfo = typeParameters.Select(p => p.Identifier.ValueText).ToList();
                                                  }
                                              }
                                              return mti;
                                          })
                                          .ToList();

            if (ret.BaseClasses?.Any(x => x.Name == nameof(IDisposable)) == true)
            {
                ret.MethodList.Add(new MethodTemplateInfo
                {
                    Name = nameof(IDisposable.Dispose),
                    ReturnTypeInfo = new TypeInfo {Name = "void"},
                    ArgumentListInfo = new List<ArgumentInfo>(),
                    IsRefitMethod = false,
                    IsDispose = true,
                    InterfaceName = nameof(IDisposable),
                });
            }

            return ret;
        }

        public void GenerateInterfaceStubs(GeneratorExecutionContext context)
        {
            context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.RefitInternalNamespace", out var refitInternalNamespace);

            refitInternalNamespace = $"{refitInternalNamespace ?? string.Empty}RefitInternalGenerated";

            string attributeText = @$"
using System;
#pragma warning disable
namespace {refitInternalNamespace}
{{
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [AttributeUsage (AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface | AttributeTargets.Delegate)]
    sealed class PreserveAttribute : Attribute
    {{
        //
        // Fields
        //
        public bool AllMembers;

        public bool Conditional;
    }}
}}
#pragma warning restore
";

            // add the attribute text
            context.AddSource("PreserveAttribute", SourceText.From(attributeText, Encoding.UTF8));

            if (!(context.SyntaxReceiver is SyntaxReceiver receiver))
                return;

            // we're going to create a new compilation that contains the attribute.
            // TODO: we should allow source generators to provide source during initialize, so that this step isn't required.
            var options = (context.Compilation as CSharpCompilation).SyntaxTrees[0].Options as CSharpParseOptions;
            var compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(attributeText, Encoding.UTF8), options));

            // get the newly bound attribute
            var preserveAttributeSymbol = compilation.GetTypeByMetadataName($"{refitInternalNamespace}.PreserveAttribute");
            var disposableInterfaceSymbol = compilation.GetTypeByMetadataName("System.IDisposable");

            // Get the type names of the attributes we're looking for
            var httpMethodAttibutes = new HashSet<ISymbol>(SymbolEqualityComparer.Default)
            {
                compilation.GetTypeByMetadataName("Refit.GetAttribute"),
                compilation.GetTypeByMetadataName("Refit.HeadAttribute"),
                compilation.GetTypeByMetadataName("Refit.PostAttribute"),
                compilation.GetTypeByMetadataName("Refit.PutAttribute"),
                compilation.GetTypeByMetadataName("Refit.DeleteAttribute"),
                compilation.GetTypeByMetadataName("Refit.PatchAttribute"),
                compilation.GetTypeByMetadataName("Refit.OptionsAttribute")
            };

            // Check the candidates and keep the ones we're actually interested in
            var methodSymbols = new List<IMethodSymbol>();
            foreach (var method in receiver.CandidateMethods)
            {
                var model = compilation.GetSemanticModel(method.SyntaxTree);

                // Get the symbol being declared by the method
                var methodSymbol = model.GetDeclaredSymbol(method);
                if (IsRefitMethod(methodSymbol, httpMethodAttibutes))
                {
                    methodSymbols.Add(methodSymbol);
                }
            }

            var keyCount = new Dictionary<string, int>();

            // group the fields by interface and generate the source
            foreach (var group in methodSymbols.GroupBy(m => m.ContainingType))
            {
                // each group is keyed by the Interface INamedTypeSymbol and contains the members
                // with a refit attribute on them. Types may contain other members, without the attribute, which we'll
                // need to check for and error out on

                var classSource = ProcessInterface(group.Key, group.ToList(), preserveAttributeSymbol, disposableInterfaceSymbol, httpMethodAttibutes, context);
             
                var keyName = group.Key.Name;
                if(keyCount.TryGetValue(keyName, out var value))
                {
                    keyName = $"{keyName}{++value}";
                }
                keyCount[keyName] = value;

                context.AddSource($"{keyName}_refit.cs", SourceText.From(classSource, Encoding.UTF8));
            }


            ///var trees = context.Compilation.SyntaxTrees.Where(c => c is CSharpSyntaxTree).ToList();



            //var interfacesToGenerate = trees.SelectMany(FindInterfacesToGenerate).ToList();


            //var templateInfo = GenerateTemplateInfoForInterfaceList(interfacesToGenerate, refitInternalNamespace);

          //  GenerateWarnings(interfacesToGenerate, context);

            //Encoders.HtmlEncode = s => s;
            //var text = Render.StringToString(ExtractTemplateSource(), templateInfo);

            //context.AddSource("Refit.GeneratedStubs.cs", text);
        }


        string ProcessInterface(INamedTypeSymbol interfaceSymbol,
                                List<IMethodSymbol> refitMethods,
                                ISymbol preserveAttributeSymbol,
                                ISymbol disposableInterfaceSymbol,
                                HashSet<ISymbol> httpMethodAttributeSymbols,
                                GeneratorExecutionContext context)
        {
            //var parent = interfaceSymbol.ContainingSymbol;
            //while(parent != null && !(parent is INamespaceSymbol))
            //{
            //    parent = parent.ContainingSymbol;
            //}

            var classSuffix = $"{interfaceSymbol.ContainingType?.Name}{interfaceSymbol.Name}";
            
            var ns = interfaceSymbol.ContainingNamespace?.ToDisplayString();

            var className = interfaceSymbol.ToDisplayString();
            var lastDot = className.LastIndexOf('.');
            if(lastDot > 0)
            {
                className = className.Substring(lastDot+1);
            }

            var classDeclaration = $"{interfaceSymbol.ContainingType?.Name}{className}";

            var source = new StringBuilder($@"
#pragma warning disable CS8632 // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.
#pragma warning disable CS8669 // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.
");

            if(interfaceSymbol.ContainingNamespace != null && !interfaceSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                source.Append(@$"
namespace {ns}
{{");
            }
            source.Append(@$"
    /// <inheritdoc />
    [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [global::System.Diagnostics.DebuggerNonUserCode]
    [{preserveAttributeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}]
    [global::System.Reflection.Obfuscation(Exclude=true)]
    partial class AutoGenerated{classDeclaration}
        : {interfaceSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}{GenerateConstraints(interfaceSymbol)}

    {{
        /// <inheritdoc />
        public global::System.Net.Http.HttpClient Client {{ get; }}
        readonly global::Refit.IRequestBuilder requestBuilder;

        /// <inheritdoc />
        public AutoGenerated{classSuffix}(global::System.Net.Http.HttpClient client, global::Refit.IRequestBuilder requestBuilder)
        {{
            Client = client;
            this.requestBuilder = requestBuilder;
        }}
    
");
            // Get any other methods on the refit interfaces. We'll need to generate something for them and warn
            var nonRefitMethods = interfaceSymbol.GetMembers().OfType<IMethodSymbol>().Except(refitMethods, SymbolEqualityComparer.Default).Cast<IMethodSymbol>().ToList();

            // get methods for all inherited
            var derivedMethods = interfaceSymbol.AllInterfaces.SelectMany(i => i.GetMembers().OfType<IMethodSymbol>()).ToList();

            // Look for disposable
            var disposeMethod = derivedMethods.Find(m => m.ContainingType?.Equals(disposableInterfaceSymbol, SymbolEqualityComparer.Default) == true);
            if(disposeMethod != null)
            {
                //remove it from the derived methods list so we don't process it with the rest
                derivedMethods.Remove(disposeMethod);
            }

            // Pull out the refit methods from the derived types
            var derivedRefitMethods = derivedMethods.Where(m => IsRefitMethod(m, httpMethodAttributeSymbols)).ToList();
            var derivedNonRefitMethods = derivedMethods.Except(derivedMethods, SymbolEqualityComparer.Default).Cast<IMethodSymbol>().ToList();

            // Handle Refit Methods
            var anyMethodsHaveNullableAgs = false;

            foreach(var method in refitMethods.Concat(derivedRefitMethods))
            {
                ProcessRefitMethod(source, method, out var anyNullable);
                if(anyNullable)
                {
                    anyMethodsHaveNullableAgs = true;
                }
            }

            // Handle non-refit Methods that aren't static or properties
            foreach(var method in nonRefitMethods.Concat(derivedNonRefitMethods))
            {
                if (method.IsStatic || method.MethodKind == MethodKind.PropertyGet || method.MethodKind == MethodKind.PropertySet)
                    continue;

                ProcessNonRefitMethod(source, method, context);
            }

            // Handle Dispose
            if(disposeMethod != null)
            {
                ProcessDisposableMethod(source, disposeMethod);
            }

            // If any types have nullable arguments
            if(anyMethodsHaveNullableAgs)
            {
                source.Append(@"
        private static Type ToNullable(Type type) => !type.IsValueType ? type : typeof(Nullable<>).MakeGenericType(type);
");
            }

            source.Append(@"
    }
");
            if(interfaceSymbol.ContainingNamespace != null && !interfaceSymbol.ContainingNamespace.IsGlobalNamespace)
            {
                source.Append(@"

}");
            }

            source.Append(@"

#pragma warning restore CS8632 // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.
#pragma warning restore CS8669 // The annotation for nullable reference types should only be used in code within a '#nullable' annotations context. Auto-generated code requires an explicit '#nullable' directive in source.
");
            return source.ToString();
        }

        void ProcessRefitMethod(StringBuilder source, IMethodSymbol methodSymbol, out bool anyMethodsAreNullable)
        {
            anyMethodsAreNullable = false;
            WriteMethodOpening(source, methodSymbol);

            source.Append("     throw new System.NotImplementedException();");

            WriteMethodClosing(source);
        }

        void ProcessDisposableMethod(StringBuilder source, IMethodSymbol methodSymbol)
        {
            WriteMethodOpening(source, methodSymbol);

            source.Append(@"
                Client?.Dispose();
");

            WriteMethodClosing(source);
        }

        string GenerateConstraints(INamedTypeSymbol iface)
        {
            var source = new StringBuilder();
            // Need to loop over the constraints and create them
            foreach(var typeParameter in iface.TypeParameters)
            {
                WriteConstraitsForTypeParameter(source, typeParameter);
            }

            return source.ToString();
        }

        void WriteConstraitsForTypeParameter(StringBuilder source, ITypeParameterSymbol typeParameter)
        {
            var parameters = new List<string>();
            if(typeParameter.HasReferenceTypeConstraint)
            {
                parameters.Add("class");
            }
            if (typeParameter.HasUnmanagedTypeConstraint)
            {
                parameters.Add("unmanaged");
            }
            if (typeParameter.HasValueTypeConstraint)
            {
                parameters.Add("struct");
            }
            if (typeParameter.HasNotNullConstraint)
            {
                parameters.Add("notnull");
            }
            foreach(var typeConstraint in typeParameter.ConstraintTypes)
            {
                parameters.Add(typeConstraint.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
            }
            // new constraint has to be last
            if (typeParameter.HasConstructorConstraint)
            {
                parameters.Add("new()");
            }

            if(parameters.Count > 0)
            {
                source.Append(@$"
         where {typeParameter.Name} : {string.Join(", ", parameters)}");
            }

        }

        void ProcessNonRefitMethod(StringBuilder source, IMethodSymbol methodSymbol, GeneratorExecutionContext context)
        {
            WriteMethodOpening(source, methodSymbol);

            source.Append(@"
                throw new NotImplementedException(""Either this method has no Refit HTTP method attribute or you've used something other than a string literal for the 'path' argument."");
");

            WriteMethodClosing(source);

            foreach(var location in methodSymbol.Locations)
            {
                var diagnostic = Diagnostic.Create(InvalidRefitMember, location, methodSymbol.ContainingType.Name, methodSymbol.Name);
                context.ReportDiagnostic(diagnostic);
            }            
        }

        void WriteMethodOpening(StringBuilder source, IMethodSymbol methodSymbol)
        {
            source.Append(@$"

        /// <ineritdoc />
        {methodSymbol.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {methodSymbol.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}.{methodSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}(");

            source.Append(string.Join(", ", methodSymbol.Parameters.Select(p => $"{p.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)} {p.MetadataName}")));

           source.Append(@")
        {");
        }

        void WriteMethodClosing(StringBuilder source) => source.Append(@"        }");


        bool IsRefitMethod(IMethodSymbol methodSymbol, HashSet<ISymbol> httpMethodAttibutes)
        {
            return methodSymbol.GetAttributes().Any(ad => httpMethodAttibutes.Contains(ad.AttributeClass));
        }

        public TemplateInformation GenerateTemplateInfoForInterfaceList(List<InterfaceDeclarationSyntax> interfaceList, string refitInternalNamespace = null)
        {
            interfaceList = interfaceList.OrderBy(i => i.Identifier.Text).ToList();

            var ret = new TemplateInformation
            {
                RefitInternalNamespace = refitInternalNamespace ?? string.Empty,
                ClassList = interfaceList.Select(GenerateClassInfoForInterface).ToList(),
            };

            AddInheritedMethods(ret.ClassList);
            FixInheritedMethods(ret.ClassList);
            MergePartialInterfaces(ret.ClassList);

            return ret;
        }

        void AddInheritedMethods(List<ClassTemplateInfo> allClassList)
        {
            allClassList.ForEach(classInfo => AddInheritedMethods(allClassList, classInfo));
        }

        void AddInheritedMethods(List<ClassTemplateInfo> allClassList, ClassTemplateInfo classInfo)
        {
            classInfo.BaseClasses?.ForEach(baseClass =>
            {
                var baseClassInfo = allClassList.SingleOrDefault(oc => oc.InterfaceName == baseClass.Name &&
                    oc.TypeParametersInfo?.Count == baseClass.TypeParametersInfo?.Count);

                if (baseClassInfo == null)
                    return;

                AddInheritedMethods(allClassList, baseClassInfo);

                var methodsToAdd = baseClassInfo.MethodList
                    .Where(a => !classInfo.MethodList.Any(b => b.InterfaceName == a.InterfaceName &&
                        b.TypeParametersInfo?.Count == a.TypeParametersInfo?.Count && b.Name == a.Name))
                    .Select(a => new MethodTemplateInfo
                    {
                        ArgumentListInfo = a.ArgumentListInfo?
                            .Select(b => new ArgumentInfo { Name = b.Name, TypeInfo = b.TypeInfo.Clone() })
                            .ToList(),
                        IsRefitMethod = a.IsRefitMethod,
                        Name = a.Name,
                        ReturnTypeInfo = a.ReturnTypeInfo.Clone(),
                        MethodTypeParameterListInfo = a.MethodTypeParameterListInfo?.ToList(),
                        InterfaceName = a.InterfaceName,
                        TypeParametersInfo = a.TypeParametersInfo?.ToList(),
                    });

                classInfo.MethodList.AddRange(methodsToAdd);

                classInfo.UsingList = classInfo.UsingList.Union(baseClassInfo.UsingList).ToList();
            });
        }

        void FixInheritedMethods(List<ClassTemplateInfo> allClassList)
        {
            allClassList.ForEach(classInfo => FixInheritedMethods(allClassList, classInfo));
        }

        List<MethodTemplateInfo> FixInheritedMethods(List<ClassTemplateInfo> allClassList, ClassTemplateInfo rootClassInfo, ClassTemplateInfo classInfo = null)
        {
            List<MethodTemplateInfo> outResult = null;

            (classInfo ?? rootClassInfo).BaseClasses?.ForEach(baseClass =>
            {
                var baseClassInfo = allClassList.SingleOrDefault(oc => oc.InterfaceName == baseClass.Name &&
                    oc.TypeParametersInfo?.Count == baseClass.TypeParametersInfo?.Count);

                if (baseClassInfo == null)
                    return;

                var baseMethods = FixInheritedMethods(allClassList, rootClassInfo, baseClassInfo);

                var parametersMap = baseClassInfo.TypeParametersInfo?.Select((a, i) =>
                    {
                        var typeInfo = baseClass.TypeParametersInfo[i];
                        return a != typeInfo.ToString() ? new { Key = a, Value = typeInfo } : null;
                    }).Where(a => a != null).ToDictionary(a => a.Key, a => a.Value);

                void replaceGenericTypes(TypeInfo typeInfo)
                {
                    if (parametersMap?.Count > 0)
                    {
                        foreach (var itemMap in parametersMap)
                        {
                            if (typeInfo.Name == itemMap.Key)
                            {
                                typeInfo.Name = itemMap.Value.Name;
                                typeInfo.Children = itemMap.Value.Children?.Select(a => a.Clone()).ToList();
                            }
                            else if (typeInfo.Children != null)
                            {
                                foreach (var item in typeInfo.Children)
                                {
                                    replaceGenericTypes(item);
                                }
                            }
                        }
                    }
                }

                string replaceGenericType(string typeInfo)
                {
                    if (parametersMap?.Count > 0)
                    {
                        if (parametersMap.TryGetValue(typeInfo, out var result))
                            return result.ToString();
                    }

                    return typeInfo;
                }

                var methods = rootClassInfo.MethodList.Where(m => m.InterfaceName == baseClassInfo.InterfaceName &&
                    m.TypeParametersInfo?.Count == baseClassInfo.TypeParametersInfo?.Count).ToList();
                if (baseMethods != null)
                    methods.AddRange(baseMethods);

                foreach (var m in methods)
                {
                    if (m.ArgumentListInfo != null)
                        foreach (var a in m.ArgumentListInfo)
                        {
                            replaceGenericTypes(a.TypeInfo);
                        }
                    replaceGenericTypes(m.ReturnTypeInfo);
                    m.TypeParametersInfo = m.TypeParametersInfo?.Select(b => replaceGenericType(b)).ToList();
                }

                outResult = methods;
            });

            return outResult;
        }

        void MergePartialInterfaces(List<ClassTemplateInfo> classList)
        {
            var partialClasses = classList
                .GroupBy(c => c.Namespace + c.InterfaceName + string.Join(".", c.TypeParameters))
                .Where(g => g.Count() > 1)
                .ToList();

            foreach (var partialGroup in partialClasses)
            {
                var firstClass = partialGroup.First();

                foreach (var otherClass in partialGroup.Skip(1))
                {
                    firstClass.MethodList.AddRange(otherClass.MethodList);
                    classList.Remove(otherClass);
                }
            }
        }

        static readonly DiagnosticDescriptor InvalidRefitMember = new DiagnosticDescriptor(
                "RF001",
                "Refit types must have Refit HTTP method attributes",
                "Method {0}.{1} either has no Refit HTTP method attribute or you've used something other than a string literal for the 'path' argument.",
                "Refit",
                DiagnosticSeverity.Warning,
                true);

        public void GenerateWarnings(List<InterfaceDeclarationSyntax> interfacesToGenerate, GeneratorExecutionContext context)
        {
            var missingAttributeWarnings = interfacesToGenerate
                                           .SelectMany(i => i.Members.OfType<MethodDeclarationSyntax>().Select(m => new
                                           {
                                               Interface = i,
                                               Method = m
                                           }))
                                           .Where(x => !x.Method.Modifiers.Any(SyntaxKind.StaticKeyword)) // Don't warn on static methods, they should not have the attribute
                                           .Where(x => !HasRefitHttpMethodAttribute(x.Method))
                                           .Select(x => Diagnostic.Create(InvalidRefitMember, x.Method.GetLocation(), x.Interface.Identifier.ToString(), x.Method.Identifier.ToString()));


            var diagnostics = missingAttributeWarnings;

            foreach (var diagnostic in diagnostics)
            {
                context.ReportDiagnostic(diagnostic);
            }
        }

        public bool HasRefitHttpMethodAttribute(MethodDeclarationSyntax method)
        {
            // We could also verify that the single argument is a string,
            // but what if somebody is dumb and uses a constant?
            // Could be turtles all the way down.
            return method.AttributeLists.SelectMany(a => a.Attributes)
                         .Any(a => HttpMethodAttributeNames.Contains(a.Name.ToString().Split('.').Last()) &&
                                   a.ArgumentList.Arguments.Count == 1 &&
                                   a.ArgumentList.Arguments[0].Expression.Kind() == SyntaxKind.StringLiteralExpression);
        }

        string GetInterfaceName(SyntaxToken identifier)
        {
            if (identifier == null) return "";
            var interfaceParent = identifier.Parent != null ? identifier.Parent.Parent : identifier.Parent;

            if ((interfaceParent as ClassDeclarationSyntax) != null)
            {
                var classParent = (interfaceParent as ClassDeclarationSyntax).Identifier;
                return classParent + "." + identifier.ValueText;
            }

            return identifier.ValueText;
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        class SyntaxReceiver : ISyntaxReceiver
        {
            public List<MethodDeclarationSyntax> CandidateMethods { get; } = new();

            public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
            {
                // We're looking for interfaces that have a method with an attribute
                if(syntaxNode is MethodDeclarationSyntax methodDeclarationSyntax &&
                   methodDeclarationSyntax.Parent is InterfaceDeclarationSyntax iface &&
                   methodDeclarationSyntax.AttributeLists.Count > 0)
                {
                    CandidateMethods.Add(methodDeclarationSyntax);
                }
            }
        }
    }

    public class UsingDeclaration
    {
        public string Item { get; set; }

        public override bool Equals(object obj)
        {
            return obj is UsingDeclaration other && Item == other.Item;
        }

        public override int GetHashCode()
        {
            return Item.GetHashCode();
        }
    }

    public class ClassTemplateInfo
    {
        public string ConstraintClauses { get; set; }
        public string GeneratedClassSuffix { get; set; }
        public string InterfaceName { get; set; }
        public List<BaseClassInfo> BaseClasses { get; set; }
        public List<MethodTemplateInfo> MethodList { get; set; }
        public bool HasAnyMethodsWithNullableArguments => MethodList.SelectMany(ml => ml.ArgumentListInfo).Any(y => y.TypeInfo.ToString().EndsWith("?"));
        public string Modifiers { get; set; }
        public string Namespace { get; set; }
        public List<string> TypeParametersInfo { get; set; }
        public string TypeParameters => TypeParametersInfo != null ? string.Join(", ", TypeParametersInfo) : null;
        public List<UsingDeclaration> UsingList { get; set; }
    }

    public class TypeInfo
    {
        public string Name { get; set; }
        public List<TypeInfo> Children { get; set; }

        public override string ToString()
        {
            return Name + (Children?.Count > 0 ? $"<{string.Join(", ", Children.Select(a => a.ToString()))}>" : null);
        }

        public TypeInfo Clone()
        {
            return CloneImpl() as TypeInfo;
        }

        protected virtual object CloneImpl()
        {
            return new TypeInfo
            {
                Name = Name,
                Children = Children?.Select(a => a.Clone()).ToList(),
            };
        }
    }

    public class BaseClassInfo
    {
        public string Name { get; set; }
        public List<TypeInfo> TypeParametersInfo { get; set; }
    }

    public class MethodTemplateInfo
    {
        public List<ArgumentInfo> ArgumentListInfo { get; set; }
        public string ArgumentList => ArgumentListInfo != null ? string.Join(", ", ArgumentListInfo.Select(y => y.Name)) : null;
        public string ArgumentListWithTypes => ArgumentListInfo != null ? string.Join(", ", ArgumentListInfo.Select(y => $"{y.TypeInfo} {y.Name}")) : null;
        public string ArgumentTypesList => ArgumentListInfo != null ? string.Join(", ", ArgumentListInfo.Select(y => y.TypeInfo.ToString() is var typeName && typeName.EndsWith("?") ? $"ToNullable(typeof({typeName.Remove(typeName.Length - 1)}))" : $"typeof({typeName})")) : null;
        public bool IsRefitMethod { get; set; }
        public bool IsDispose { get; set; }
        public bool UnsupportedMethod => !IsRefitMethod && !IsDispose;
        public string Name { get; set; }
        public TypeInfo ReturnTypeInfo { get; set; }
        public string ReturnType => ReturnTypeInfo.ToString();
        public List<string> MethodTypeParameterListInfo { get; set; }
        public string MethodTypeParameters => MethodTypeParameterListInfo != null ? string.Join(", ", MethodTypeParameterListInfo) : null;
        public string MethodTypeParameterList => MethodTypeParameterListInfo != null ? string.Join(", ", MethodTypeParameterListInfo.Select(p => $"typeof({p})")) : null;
        public string MethodTypeParameterNames => MethodTypeParameterListInfo != null ? $"{string.Join(", ", MethodTypeParameterListInfo.Select(p => $"{{typeof({p}).AssemblyQualifiedName}}"))}" : null;
        public string InterfaceName { get; set; }
        public List<string> TypeParametersInfo { get; set; }
        public string TypeParameters => TypeParametersInfo != null ? string.Join(", ", TypeParametersInfo) : null;
    }

    public class ArgumentInfo
    {
        public string Name { get; set; }
        public TypeInfo TypeInfo { get; set; }
    }

    public class TemplateInformation
    {
        public string RefitInternalNamespace { get; set; }
        public List<ClassTemplateInfo> ClassList;
    }

    static class InterfaceDeclarationExtension
    {
        public static IEnumerable<InterfaceDeclarationSyntax> DescendantsAndSelf(this InterfaceDeclarationSyntax interfaceDeclaration,
            Func<InterfaceDeclarationSyntax, IEnumerable<InterfaceDeclarationSyntax>> childrenFunc)
        {
            yield return interfaceDeclaration;

            var children = childrenFunc(interfaceDeclaration)?.Where(x => x != null).SelectMany(x => x.DescendantsAndSelf(childrenFunc));

            if (children != null)
            {
                foreach (var item in children)
                {
                    yield return item;
                }
            }
        }

        public static SimpleNameSyntax GetSimpleName(this BaseTypeSyntax baseType)
        {
            if (baseType is SimpleBaseTypeSyntax simpleBaseType && simpleBaseType.Type is SimpleNameSyntax simpleName)
                return simpleName;

            return null;
        }

        public static InterfaceDeclarationSyntax GetInterfaceDeclaration(this SimpleNameSyntax simpleName, IEnumerable<InterfaceDeclarationSyntax> list)
        {
            if (simpleName == null)
                return null;

            var result = list.FirstOrDefault(c => c.Identifier.ValueText == simpleName.Identifier.ValueText &&
                c.TypeParameterList?.Parameters.Count ==
                    (simpleName is GenericNameSyntax genericName ? genericName.TypeArgumentList.Arguments.Count : 0));

            return result;
        }

        public static TypeInfo GetTypeInfo(this TypeSyntax typeSyntax)
        {
            if (typeSyntax is GenericNameSyntax g)
                return new TypeInfo { Name = g.Identifier.ValueText, Children = g.TypeArgumentList.Arguments.Select(a => a.GetTypeInfo()).ToList() };
            else
                return new TypeInfo { Name = typeSyntax.ToString() };
        }
    }
}
